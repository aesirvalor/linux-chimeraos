From 732f7edc4de9eff218b50f55fd9491df8156f506 Mon Sep 17 00:00:00 2001
From: Denis <benato.denis96@gmail.com>
Date: Thu, 2 Nov 2023 02:31:27 +0100
Subject: [PATCH 3/4] asus hid: set led brightness at resume as it was left
 before sleep

---
 drivers/hid/hid-asus.c | 100 ++++++++++++++++++++---------------------
 1 file changed, 48 insertions(+), 52 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index e745717a4a36..3b3ae9e5b4ae 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -836,8 +836,6 @@ static ssize_t switch_mode_store(struct device *raw_dev, struct device_attribute
 			return -EINVAL;
 	}
 
-	hid_err(hdev, "Ally controller mode switch to %d mode op result: %d\n", val, res);
-
 	return count;
 }
 
@@ -1672,20 +1670,47 @@ static int asus_start_multitouch(struct hid_device *hdev)
 
 static int __maybe_unused asus_reset_resume(struct hid_device *hdev)
 {
+	int ret = 0;
+
 	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
+	if (drvdata != NULL) {
+		return -EINVAL;
+	}
 
-	int ret = 0;
+	if (drvdata->tp)
+		return asus_start_multitouch(hdev);
 
-/*
-	// Controller mode is kept on device sleep
-	if (dmi_match(DMI_PRODUCT_NAME, "ROG Ally RC71L_RC71L"))
-	{
-		// Apply the joystick mode switch
-		ret = rog_ally_controller_mode_change(hdev, game_mode);
+	return ret;
+}
 
-		hid_err(hdev, "Asus wake, restore controller %d\n", ret);
+static int __maybe_unused asus_suspend(struct hid_device *hdev, struct pm_message)
+{
+	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
+
+	if (drvdata == NULL) {
+		return 0;
 	}
-*/
+
+	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+	struct usb_device *dev = interface_to_usbdev(intf);
+
+	int ret = 0;
+
+	struct asus_rc71l *rc71l_drvdata = drvdata->rc71l_data;
+	if (rc71l_drvdata != NULL) {
+		mutex_lock(&rc71l_drvdata->mutex);
+		// TODO: send ABOIRT_PIPE here
+		mutex_unlock(&rc71l_drvdata->mutex);
+	}
+
+	return ret;
+}
+
+static int __maybe_unused asus_resume(struct hid_device *hdev)
+{
+	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
+
+	int ret = 0;
 
 	struct asus_rc71l *rc71l_drvdata = drvdata->rc71l_data;
 	if (rc71l_drvdata != NULL) {
@@ -1695,63 +1720,34 @@ static int __maybe_unused asus_reset_resume(struct hid_device *hdev)
 
 		if (ret < 0) {
 			hid_err(hdev, "ROG Ally [RC71L] failed to reset controller mode: %d\n", ret);
-			goto asus_reset_resume_err;
+			goto asus_resume_err;
 		}
-	}
 
-	if (drvdata->kbd_backlight) {
 		/*
-		 *	From the power management documentation:
+		 * From the power management documentation:
 		 *	The reset_resume method is called to tell the driver that the device has been resumed and it also has been reset.
 		 *  The driver should redo any necessary device initialization, since the device has probably lost most or all of its state
 		 *  (although the interfaces will be in the same altsettings as before the suspend).
 		 *
 		 * For the asus RC71L this is true and the "keyboard" device is facing directly the user, therefore to not bother the user
-		 * with LEDs suddently turning ON after sleeping the device the same led leves is set.
+		 * with LEDs suddently turning ON after sleeping the device the same led leves are to be set.
 		 */
+		if (drvdata->kbd_backlight) {
+			const u8 buf[] = { FEATURE_KBD_REPORT_ID, 0xba, 0xc5, 0xc4, drvdata->kbd_backlight->cdev.brightness };
+			ret = asus_kbd_set_report(hdev, buf, sizeof(buf));
+			if (ret < 0) {
+				hid_err(hdev, "Asus failed to set keyboard backlight: %d\n", ret);
+				goto asus_resume_err;
+			}
 
-		ret = asus_kbd_init(hdev);
-		if (ret < 0) {
-			hid_err(hdev, "Asus failed to reinitialize keyboard: %d\n", ret);
-			goto asus_reset_resume_err;
+			hid_err(hdev, "Asus ROG Ally asus_reset_resume, leds reset: %d at brightness %d\n", ret, (int)drvdata->kbd_backlight->cdev.brightness);
 		}
-
-		/*
-		ret = asus_kbd_get_functions(hdev, &kbd_func);
-		if (ret < 0)
-			return ret;
-		*/
-
-		drvdata->kbd_backlight->cdev.brightness_set(&drvdata->kbd_backlight->cdev, drvdata->kbd_backlight->cdev.brightness);
 	}
 
-	if (drvdata->tp)
-		return asus_start_multitouch(hdev);
-
-asus_reset_resume_err:
+asus_resume_err:
 	return ret;
 }
 
-#ifdef CONFIG_PM
-static int __maybe_unused asus_suspend(struct hid_device *hdev, struct pm_message)
-{
-	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
-
-	int ret = 0;
-
-	return ret;
-}
-
-static int __maybe_unused asus_resume(struct hid_device *hdev)
-{
-	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
-
-	int ret = 0;
-
-	return ret;
-}
-#endif
-
 static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)
 {
 	int ret;
-- 
2.42.0

