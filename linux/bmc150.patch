From 6c79107a19740fd9fff05f3d1ca1232ae2a8cb07 Mon Sep 17 00:00:00 2001
From: Denis <benato.denis96@gmail.com>
Date: Mon, 18 Sep 2023 01:57:19 +0200
Subject: [PATCH 1/2] Fixed all warnings, code almost ready to be upstreamed

---
 drivers/iio/accel/bmc150-accel-core.c | 1882 ++++++++++++++++++++++++-
 drivers/iio/accel/bmc150-accel-i2c.c  |   93 +-
 drivers/iio/accel/bmc150-accel.h      |   90 +-
 3 files changed, 2054 insertions(+), 11 deletions(-)

diff --git a/drivers/iio/accel/bmc150-accel-core.c b/drivers/iio/accel/bmc150-accel-core.c
index 110591804b4c..5ac25c344385 100644
--- a/drivers/iio/accel/bmc150-accel-core.c
+++ b/drivers/iio/accel/bmc150-accel-core.c
@@ -130,6 +130,71 @@
 #define BMC150_ACCEL_REG_FIFO_DATA		0x3F
 #define BMC150_ACCEL_FIFO_LENGTH		32
 
+#define BMC150_BMI323_TEMPER_CENTER_VAL 23
+#define BMC150_BMI323_TEMPER_LSB_PER_KELVIN_VAL 512
+
+#define BMC150_BMI323_AUTO_SUSPEND_DELAY_MS 2000
+
+#define BMC150_BMI323_CHIP_ID_REG			0x00
+#define BMC150_BMI323_SOFT_RESET_REG		0x7E
+#define BMC150_BMI323_SOFT_RESET_VAL		0xDEAFU
+#define BMC150_BMI323_DATA_BASE_REG			0x03
+#define BMC150_BMI323_TEMPERATURE_DATA_REG	0x09
+#define BMC150_BMI323_ACC_CONF_REG			0x20
+#define BMC150_BMI323_GYR_CONF_REG			0x21
+#define BMC150_BMI323_FIFO_CONF_REG			0x36
+
+// these are bits [0:3] of ACC_CONF.acc_odr, sample rate in Hz for the accel part of the chip
+#define BMC150_BMI323_ACCEL_ODR_0_78123_VAL	0x0001
+#define BMC150_BMI323_ACCEL_ODR_1_5625_VAL	0x0002
+#define BMC150_BMI323_ACCEL_ODR_3_125_VAL	0x0003
+#define BMC150_BMI323_ACCEL_ODR_6_25_VAL	0x0004
+#define BMC150_BMI323_ACCEL_ODR_12_5_VAL	0x0005
+#define BMC150_BMI323_ACCEL_ODR_25_VAL		0x0006
+#define BMC150_BMI323_ACCEL_ODR_50_VAL		0x0007
+#define BMC150_BMI323_ACCEL_ODR_100_VAL		0x0008
+#define BMC150_BMI323_ACCEL_ODR_200_VAL		0x0009
+#define BMC150_BMI323_ACCEL_ODR_400_VAL		0x000A
+#define BMC150_BMI323_ACCEL_ODR_800_VAL		0x000B
+#define BMC150_BMI323_ACCEL_ODR_1600_VAL	0x000C
+#define BMC150_BMI323_ACCEL_ODR_3200_VAL	0x000D
+#define BMC150_BMI323_ACCEL_ODR_6400_VAL	0x000E
+
+#define BMC150_BMI323_ACCEL_BW_ODR_2_VAL	0x0000
+#define BMC150_BMI323_ACCEL_BW_ODR_4_VAL	0x0001
+
+// these are bits [4:6] of ACC_CONF.acc_range, full scale resolution
+#define BMC150_BMI323_ACCEL_RANGE_2_VAL		0x0000 // +/-2g, 16.38 LSB/mg
+#define BMC150_BMI323_ACCEL_RANGE_4_VAL		0x0001 // +/-4g, 8.19 LSB/mg
+#define BMC150_BMI323_ACCEL_RANGE_8_VAL		0x0002 // +/-8g, 4.10 LSB/mg
+#define BMC150_BMI323_ACCEL_RANGE_16_VAL	0x0003 // +/-4g, 2.05 LSB/mg
+
+// these are bits [0:3] of GYR_CONF.gyr_odr, sample rate in Hz for the gyro part of the chip
+#define BMC150_BMI323_GYRO_ODR_0_78123_VAL	0x0001
+#define BMC150_BMI323_GYRO_ODR_1_5625_VAL	0x0002
+#define BMC150_BMI323_GYRO_ODR_3_125_VAL	0x0003
+#define BMC150_BMI323_GYRO_ODR_6_25_VAL		0x0004
+#define BMC150_BMI323_GYRO_ODR_12_5_VAL		0x0005
+#define BMC150_BMI323_GYRO_ODR_25_VAL		0x0006
+#define BMC150_BMI323_GYRO_ODR_50_VAL		0x0007
+#define BMC150_BMI323_GYRO_ODR_100_VAL		0x0008
+#define BMC150_BMI323_GYRO_ODR_200_VAL		0x0009
+#define BMC150_BMI323_GYRO_ODR_400_VAL		0x000A
+#define BMC150_BMI323_GYRO_ODR_800_VAL		0x000B
+#define BMC150_BMI323_GYRO_ODR_1600_VAL		0x000C
+#define BMC150_BMI323_GYRO_ODR_3200_VAL		0x000D
+#define BMC150_BMI323_GYRO_ODR_6400_VAL		0x000E
+
+#define BMC150_BMI323_GYRO_BW_ODR_2_VAL		0x0000
+#define BMC150_BMI323_GYRO_BW_ODR_4_VAL		0x0001
+
+// these are bits [4:6] of GYR_CONF.gyr_range, full scale resolution
+#define BMC150_BMI323_GYRO_RANGE_125_VAL	0x0000 // +/-125°/s, 262.144 LSB/°/s
+#define BMC150_BMI323_GYRO_RANGE_250_VAL	0x0001 // +/-250°/s,  131.2 LSB/°/s
+#define BMC150_BMI323_GYRO_RANGE_500_VAL	0x0002 // +/-500°/s,  65.6 LSB/°/s
+#define BMC150_BMI323_GYRO_RANGE_1000_VAL	0x0003 // +/-1000°/s, 32.8 LSB/°/s
+#define BMC150_BMI323_GYRO_RANGE_2000_VAL	0x0004 // +/-2000°/s, 16.4 LSB/°/s
+
 enum bmc150_accel_axis {
 	AXIS_X,
 	AXIS_Y,
@@ -149,6 +214,646 @@ struct bmc150_scale_info {
 	u8 reg_range;
 };
 
+/*
+ * This enum MUST not be altered as there are parts in the code that
+ * uses an int conversion to get the correct device register to read.
+ */
+enum bmi323_axis {
+	BMI323_ACCEL_AXIS_X = 0,
+	BMI323_ACCEL_AXIS_Y,
+	BMI323_ACCEL_AXIS_Z,
+	BMI323_GYRO_AXIS_X,
+	BMI323_GYRO_AXIS_Y,
+	BMI323_GYRO_AXIS_Z,
+	BMI323_TEMP,
+	BMI323_AXIS_MAX,
+};
+
+static const struct bmi323_scale_accel_info {
+	u8 hw_val;
+	int val;
+	int val2;
+	int ret_type;
+} bmi323_accel_scale_map[] = {
+	{
+		.hw_val = (u16)BMC150_BMI323_ACCEL_RANGE_2_VAL << (u16)4,
+		.val = 0,
+		.val2 = 598,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_ACCEL_RANGE_4_VAL << (u16)4,
+		.val = 0,
+		.val2 = 1196,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_ACCEL_RANGE_8_VAL << (u16)4,
+		.val = 0,
+		.val2 = 2392,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_ACCEL_RANGE_16_VAL << (u16)4,
+		.val = 0,
+		.val2 = 4785,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+};
+
+static const struct bmi323_scale_gyro_info {
+	u8 hw_val;
+	int val;
+	int val2;
+	int ret_type;
+} bmi323_gyro_scale_map[] = {
+	{
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_125_VAL << (u16)4,
+		.val = 0,
+		.val2 = 66545,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_125_VAL << (u16)4,
+		.val = 0,
+		.val2 = 66,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_250_VAL << (u16)4,
+		.val = 0,
+		.val2 = 133090,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_250_VAL << (u16)4,
+		.val = 0,
+		.val2 = 133,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_500_VAL << (u16)4,
+		.val = 0,
+		.val2 = 266181,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_500_VAL << (u16)4,
+		.val = 0,
+		.val2 = 266,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_1000_VAL << (u16)4,
+		.val = 0,
+		.val2 = 532362,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_1000_VAL << (u16)4,
+		.val = 0,
+		.val2 = 532,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_2000_VAL << (u16)4,
+		.val = 0,
+		.val2 = 1064724,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+	{ // this shouldn't be necessary, but iio seems to have a wrong rounding of this value...
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_2000_VAL << (u16)4,
+		.val = 0,
+		.val2 = 1064,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+	{
+		.hw_val = (u16)BMC150_BMI323_GYRO_RANGE_2000_VAL << (u16)4,
+		.val = 0,
+		.val2 = 1065,
+		.ret_type = IIO_VAL_INT_PLUS_NANO,
+	},
+};
+
+/*
+ * this reflects the frequency map that is following.
+ * For each index i of that map index i*2 and i*2+1 of of this
+ * holds ODR/2 and ODR/4
+ */ 
+static const struct bmi323_3db_freq_cutoff_accel_info {
+	int val;
+	int val2;
+	int ret_type;
+} bmi323_accel_3db_freq_cutoff[] = {
+	{
+		.val = 0,
+		.val2 = 390615,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 0,
+		.val2 = 195308,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 0,
+		.val2 = 781300,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 0,
+		.val2 = 390650,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 1,
+		.val2 = 562500,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 0,
+		.val2 = 78125,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 3,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 1,
+		.val2 = 500000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 6,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 3,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 12,
+		.val2 = 500000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 6,
+		.val2 = 250000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 25,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 12,
+		.val2 = 500000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 50,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 25,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 100,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 50,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 200,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 100,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 400,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 200,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 800,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 400,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 1600,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 800,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 1600,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 800,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 3200,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 1600,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+};
+
+static const struct bmi323_freq_accel_info {
+	u8 hw_val;
+	int val;
+	int val2;
+} bmi323_accel_odr_map[] = {
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_0_78123_VAL,
+		.val = 0,
+		.val2 = 781230,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_1_5625_VAL,
+		.val = 1,
+		.val2 = 562600,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_3_125_VAL,
+		.val = 3,
+		.val2 = 125000,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_6_25_VAL,
+		.val = 6,
+		.val2 = 250000,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_12_5_VAL,
+		.val = 12,
+		.val2 = 500000,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_25_VAL,
+		.val = 25,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_50_VAL,
+		.val = 50,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_100_VAL,
+		.val = 100,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_200_VAL,
+		.val = 200,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_400_VAL,
+		.val = 400,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_800_VAL,
+		.val = 800,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_1600_VAL,
+		.val = 1600,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_3200_VAL,
+		.val = 3200,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_ACCEL_ODR_6400_VAL,
+		.val = 6400,
+		.val2 = 0,
+	},
+};
+
+static const struct bmi323_freq_gyro_info {
+	u8 hw_val;
+	int val;
+	int val2;
+} bmi323_gyro_odr_map[] = {
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_0_78123_VAL,
+		.val = 0,
+		.val2 = 781230,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_1_5625_VAL,
+		.val = 1,
+		.val2 = 562600,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_3_125_VAL,
+		.val = 3,
+		.val2 = 125000,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_6_25_VAL,
+		.val = 6,
+		.val2 = 250000,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_12_5_VAL,
+		.val = 12,
+		.val2 = 500000,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_25_VAL,
+		.val = 25,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_50_VAL,
+		.val = 50,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_100_VAL,
+		.val = 100,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_200_VAL,
+		.val = 200,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_400_VAL,
+		.val = 400,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_800_VAL,
+		.val = 800,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_1600_VAL,
+		.val = 1600,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_3200_VAL,
+		.val = 3200,
+		.val2 = 0,
+	},
+	{
+		.hw_val = BMC150_BMI323_GYRO_ODR_6400_VAL,
+		.val = 6400,
+		.val2 = 0,
+	},
+};
+
+static const struct bmi323_3db_freq_cutoff_gyro_info {
+	int val;
+	int val2;
+	int ret_type;
+} bmi323_gyro_3db_freq_cutoff[] = {
+	{
+		.val = 0,
+		.val2 = 390615,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 0,
+		.val2 = 1953075, // TODO: check if this gets reported correctly...
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 0,
+		.val2 = 781300,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 0,
+		.val2 = 390650,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 1,
+		.val2 = 562500,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 0,
+		.val2 = 78125,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 3,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 1,
+		.val2 = 500000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 6,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 3,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 12,
+		.val2 = 500000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 6,
+		.val2 = 250000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 25,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 12,
+		.val2 = 500000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 50,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 25,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 100,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 50,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 200,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 100,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 400,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 200,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 800,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 400,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 1600,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 800,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 1600,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 800,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 3200,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+	{
+		.val = 1600,
+		.val2 = 000000,
+		.ret_type = IIO_VAL_INT_PLUS_MICRO,
+	},
+};
+
+static const int bmi323_accel_scales[] = {
+	0, 598,
+	0, 1196,
+	0, 2392,
+	0, 4785,
+};
+
+static const int bmi323_gyro_scales[] = {
+	0, 66545,
+	0, 133090,
+	0, 266181,
+	0, 532362,
+	0, 1064724,
+};
+
+static const int bmi323_sample_freqs[] = {
+	0, 781230,
+	1, 562600,
+	3, 125000,
+	6, 250000,
+	12, 500000,
+	25, 0,
+	50, 0,
+	100, 0,
+	200, 0,
+	400, 0,
+	800, 0,
+	1600, 0,
+	3200, 0,
+	6400, 0,
+};
+
+static const struct {
+	int val;
+	int val2; // IIO_VAL_INT_PLUS_MICRO
+	u8 bw_bits;
+} bmi323_samp_freq_table[] = { {15, 620000, 0x08},
+				     {31, 260000, 0x09},
+				     {62, 500000, 0x0A},
+				     {125, 0, 0x0B},
+				     {250, 0, 0x0C},
+				     {500, 0, 0x0D},
+				     {1000, 0, 0x0E},
+				     {2000, 0, 0x0F} };
+
+
 struct bmc150_accel_chip_info {
 	const char *name;
 	u8 chip_id;
@@ -1085,7 +1790,7 @@ static const struct attribute_group bmc150_accel_attrs_group = {
 	.attrs = bmc150_accel_attributes,
 };
 
-static const struct iio_event_spec bmc150_accel_event = {
+static const struct iio_event_spec bmi323_accel_event = {
 		.type = IIO_EV_TYPE_ROC,
 		.dir = IIO_EV_DIR_EITHER,
 		.mask_separate = BIT(IIO_EV_INFO_VALUE) |
@@ -1093,8 +1798,16 @@ static const struct iio_event_spec bmc150_accel_event = {
 				 BIT(IIO_EV_INFO_PERIOD)
 };
 
-#define BMC150_ACCEL_CHANNEL(_axis, bits) {				\
-	.type = IIO_ACCEL,						\
+static const struct iio_event_spec bmc150_accel_event = {
+		.type = IIO_EV_TYPE_ROC,
+		.dir = IIO_EV_DIR_EITHER,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE) |
+				 BIT(IIO_EV_INFO_ENABLE) |
+				 BIT(IIO_EV_INFO_PERIOD)
+};
+
+#define BMC150_ACCEL_CHANNEL(_axis, bits) {				\
+	.type = IIO_ACCEL,						\
 	.modified = 1,							\
 	.channel2 = IIO_MOD_##_axis,					\
 	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),			\
@@ -1113,6 +1826,49 @@ static const struct iio_event_spec bmc150_accel_event = {
 	.num_event_specs = 1						\
 }
 
+#define BMI323_ACCEL_CHANNEL(_axis, bits) {				\
+	.type = IIO_ACCEL,						\
+	.modified = 1,							\
+	.channel2 = IIO_MOD_##_axis,					\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),		\
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)		\
+				| BIT(IIO_CHAN_INFO_SAMP_FREQ)        \
+				| BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),		\
+	.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SAMP_FREQ) \
+				| BIT(IIO_CHAN_INFO_SCALE), \
+	.scan_index = BMI323_ACCEL_AXIS_##_axis,					\
+	.scan_type = {							\
+		.sign = 's',						\
+		.realbits = (bits),					\
+		.storagebits = 16,					\
+		.shift = 16 - (bits),					\
+		.endianness = IIO_LE,					\
+	},								\
+}
+
+#define BMI323_GYRO_CHANNEL(_axis, bits) {				\
+	.type = IIO_ANGL_VEL,						\
+	.modified = 1,							\
+	.channel2 = IIO_MOD_##_axis,					\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),			\
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)		\
+				| BIT(IIO_CHAN_INFO_SAMP_FREQ)        \
+				| BIT(IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY),		\
+	.info_mask_shared_by_type_available = BIT(IIO_CHAN_INFO_SAMP_FREQ) \
+				| BIT(IIO_CHAN_INFO_SCALE), \
+	.scan_index = BMI323_GYRO_AXIS_##_axis,					\
+	.scan_type = {							\
+		.sign = 's',						\
+		.realbits = (bits),					\
+		.storagebits = 16,					\
+		.shift = 16 - (bits),					\
+		.endianness = IIO_LE,					\
+	},								\
+	/*.ext_info = bmi323_accel_ext_info,*/				\
+	/*.event_spec = &bmi323_accel_event,*/				\
+	/*.num_event_specs = 1*/						\
+}
+
 #define BMC150_ACCEL_CHANNELS(bits) {					\
 	{								\
 		.type = IIO_TEMP,					\
@@ -1595,7 +2351,7 @@ static int bmc150_accel_chip_init(struct bmc150_accel_data *data)
 	struct device *dev = regmap_get_device(data->regmap);
 	int ret, i;
 	unsigned int val;
-
+	
 	/*
 	 * Reset chip to get it in a known good state. A delay of 1.8ms after
 	 * reset is required according to the data sheets of supported chips.
@@ -1677,6 +2433,11 @@ int bmc150_accel_core_probe(struct device *dev, struct regmap *regmap, int irq,
 	data = iio_priv(indio_dev);
 	dev_set_drvdata(dev, indio_dev);
 
+	/*
+	 * Setting the dev_type here is necessary to avoid having it left uninitialized
+	 * and therefore potentially executing bmi323 functions for the original bmc150 model.
+	 */
+	data->dev_type = BMC150;
 	data->regmap = regmap;
 	data->type = type;
 
@@ -1713,7 +2474,7 @@ int bmc150_accel_core_probe(struct device *dev, struct regmap *regmap, int irq,
 	ret = bmc150_accel_chip_init(data);
 	if (ret < 0)
 		goto err_disable_regulators;
-
+	
 	mutex_init(&data->mutex);
 
 	indio_dev->channels = data->chip_info->channels;
@@ -1826,12 +2587,1001 @@ void bmc150_accel_core_remove(struct device *dev)
 }
 EXPORT_SYMBOL_NS_GPL(bmc150_accel_core_remove, IIO_BMC150);
 
+struct device* bmi323_get_managed_device(struct bmi323_private_data *bmi323) {
+	if (bmi323->i2c_client != NULL)
+		return &bmi323->i2c_client->dev;
+
+	return &bmi323->spi_client->dev;
+}
+
+static int bmi323_set_power_state(struct bmi323_private_data *bmi323, bool on) {
+#ifdef CONFIG_PM
+	struct device *dev = bmi323_get_managed_device(bmi323);
+	int ret;
+
+	if (on)
+		ret = pm_runtime_get_sync(dev);
+	else {
+		pm_runtime_mark_last_busy(dev);
+		ret = pm_runtime_put_autosuspend(dev);
+	}
+
+	if (ret < 0) {
+		dev_err(dev, "bmi323_set_power_state failed with %d\n", on);
+
+		if (on)
+			pm_runtime_put_noidle(dev);
+
+		return ret;
+	}
+#endif
+
+	return 0;
+}
+
+int bmi323_write_u16(struct bmi323_private_data *bmi323, u8 in_reg, u16 in_value) {
+	s32 ret;
+
+	if (bmi323->i2c_client != NULL) {
+		ret = i2c_smbus_write_i2c_block_data(bmi323->i2c_client, in_reg, sizeof(in_value), (u8*)(&in_value));
+		if (ret != 0) {
+			return -2;
+		}
+
+		return 0;
+	} else if (bmi323->spi_client != NULL) {
+
+		/*
+		 * To whoever may need this: implementing this should be straightforward:
+		 * it's specular to the i2c part.
+		 */
+
+		return -EINVAL; // TODO: change with 0 once implemented
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_NS_GPL(bmi323_write_u16, IIO_BMC150);
+
+int bmi323_read_u16(struct bmi323_private_data *bmi323, u8 in_reg, u16* out_value) {
+	s32 ret;
+	u8 read_bytes[4];
+
+	if (bmi323->i2c_client != NULL) {
+		ret = i2c_smbus_read_i2c_block_data(bmi323->i2c_client, in_reg, sizeof(read_bytes), &read_bytes[0]);
+		if (ret != 4) {
+			return ret;
+		}
+
+		// DUMMY	= read_bytes[0]
+		// DUMMY	= read_bytes[1]
+		// LSB		= read_bytes[2]
+		// MSB		= read_bytes[3]
+		u8* o = (u8*)out_value;
+		o[0] = read_bytes[2];
+		o[1] = read_bytes[3];
+
+		return 0;
+	} else if (bmi323->spi_client != NULL) {
+		printk(KERN_CRIT "bmi323: SPI interface is not yet implemented.\n");
+
+		/*
+		 * To whoever may need this: implementing this should be straightforward:
+		 * it's specular to the i2c part except that the dummy data is just 1 byte.
+		 */
+
+		return -EINVAL; // TODO: change with 0 once implemented
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_NS_GPL(bmi323_read_u16, IIO_BMC150);
+
+int bmi323_chip_check(struct bmi323_private_data *bmi323)
+{
+	u16 chip_id;
+	int ret;
+
+	ret = bmi323_read_u16(bmi323, BMC150_BMI323_CHIP_ID_REG, &chip_id);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (((chip_id) & 0x00FF) != cpu_to_le16((u16)0x0043U)) {
+		dev_err(bmi323->dev, "bmi323_chip_check failed with: %d; chip_id = 0x%04x", ret, chip_id);
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_NS_GPL(bmi323_chip_check, IIO_BMC150);
+
+static irqreturn_t bmi323_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+/*	
+	struct bmc150_accel_data *data = iio_priv(indio_dev);
+	
+	int ret;
+
+	mutex_lock(&data->mutex);
+	ret = regmap_bulk_read(data->regmap, BMC150_ACCEL_REG_XOUT_L,
+			       data->buffer, AXIS_MAX * 2);
+	mutex_unlock(&data->mutex);
+	if (ret < 0)
+		goto err_read;
+
+	iio_push_to_buffers_with_timestamp(indio_dev, data->buffer,
+					   pf->timestamp);
+err_read:
+*/
+	iio_trigger_notify_done(indio_dev->trig);
+
+
+	return IRQ_HANDLED;
+}
+
+static int bmi323_buffer_preenable(struct iio_dev *indio_dev)
+{
+	struct bmc150_accel_data *data = iio_priv(indio_dev);
+
+	return bmi323_set_power_state(&data->bmi323, true);
+}
+
+static int bmi323_buffer_postenable(struct iio_dev *indio_dev)
+{
+	//struct bmc150_accel_data *data = iio_priv(indio_dev);
+	
+	/*
+	 * This code is a placeholder until I can get a way to test it
+	 */
+
+	return 0;
+}
+
+static int bmi323_buffer_predisable(struct iio_dev *indio_dev)
+{
+	//struct bmc150_accel_data *data = iio_priv(indio_dev);
+
+	/*
+	 * This code is a placeholder until I can get a way to test it
+	 */
+
+	return 0;
+}
+
+static int bmi323_buffer_postdisable(struct iio_dev *indio_dev)
+{
+	struct bmc150_accel_data *data = iio_priv(indio_dev);
+
+	return bmi323_set_power_state(&data->bmi323, true);
+}
+
+static const struct iio_buffer_setup_ops bmi323_buffer_ops = {
+	.preenable = bmi323_buffer_preenable,
+	.postenable = bmi323_buffer_postenable,
+	.predisable = bmi323_buffer_predisable,
+	.postdisable = bmi323_buffer_postdisable,
+};
+
+int bmi323_chip_rst(struct bmi323_private_data *bmi323) {
+	u16 sensor_status = 0x0000, device_status = 0x0000;
+	int ret;
+
+	ret = bmi323_write_u16(bmi323, BMC150_BMI323_SOFT_RESET_REG, cpu_to_le16((u16)BMC150_BMI323_SOFT_RESET_VAL));
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* wait the specified amount of time... I agree with the bmc150 module: better safe than sorry. */
+	msleep(5);
+
+	// if the device is connected over SPI a dummy read is to be performed once after each reset
+	if (bmi323->spi_client != NULL) {
+		dev_err(bmi323->dev, "issuing the dummy read to switch mode to SPI");
+
+		// do not even check the result of that... it's just a dummy read
+		bmi323_chip_check(bmi323);
+	}
+
+	ret = bmi323_chip_check(bmi323);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* now check the correct initialization status as per datasheet */
+	ret = bmi323_read_u16(bmi323, 0x01, &device_status);
+	if (ret != 0) {
+		return -3;
+	}
+
+	if ((device_status & cpu_to_le16((u16)0x00FFU)) != cpu_to_le16((u16)0x0000U)) {
+		dev_err(bmi323->dev, "bmi323: device_status incorrect: %d; device_status = 0x%04x", ret, device_status);
+
+		/* from the datasheet: power error */
+		return -4;
+	}
+
+	/* from the datasheet: power ok */
+	ret = bmi323_read_u16(bmi323, 0x02, &sensor_status);
+	if (ret != 0) {
+		return -5;
+	}
+
+	if ((sensor_status & cpu_to_le16((u16)0x00FFU)) != cpu_to_le16((u16)0x0001U)) {
+		dev_err(bmi323->dev, "bmi323: sensor_status incorrect: %d; sensor_status = 0x%04x", ret, sensor_status);
+
+		/* from the datasheet: initialization error */
+		return -6;
+	}
+
+	/* from the datasheet: initialization ok */
+	return 0;
+}
+EXPORT_SYMBOL_NS_GPL(bmi323_chip_rst, IIO_BMC150);
+
+static const struct iio_chan_spec bmi323_channels[] = {
+	BMI323_ACCEL_CHANNEL(X, 16),
+	BMI323_ACCEL_CHANNEL(Y, 16),
+	BMI323_ACCEL_CHANNEL(Z, 16),
+	BMI323_GYRO_CHANNEL(X, 16),
+	BMI323_GYRO_CHANNEL(Y, 16),
+	BMI323_GYRO_CHANNEL(Z, 16),
+	{
+		.type = IIO_TEMP,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |
+				      BIT(IIO_CHAN_INFO_SCALE) |
+				      BIT(IIO_CHAN_INFO_OFFSET),
+		.scan_index = BMI323_TEMP,
+	},
+	IIO_CHAN_SOFT_TIMESTAMP(BMI323_AXIS_MAX),
+};
+
+static int bmi323_read_raw(struct iio_dev *indio_dev,
+				 struct iio_chan_spec const *chan,
+				 int *val, int *val2, long mask)
+{
+	struct bmc150_accel_data *data = iio_priv(indio_dev);
+	int ret = -EINVAL, was_sleep_modified = -1;
+	u16 raw_read = 0x8000;
+
+	mutex_lock(&data->bmi323.mutex);
+
+	if ((data->bmi323.flags & BMI323_FLAGS_RESET_FAILED) != 0x00U) {
+		dev_err(data->bmi323.dev, "bmi323 error: device has not being woken up correctly.");
+		mutex_unlock(&data->bmi323.mutex);
+		return -EBUSY;
+	}
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		{
+			switch (chan->type) {
+			case IIO_TEMP:
+				was_sleep_modified = bmi323_set_power_state(&data->bmi323, true);
+				if (was_sleep_modified != 0) {
+					ret = was_sleep_modified;
+					goto bmi323_read_raw_error_power;
+				}
+
+				ret = iio_device_claim_direct_mode(indio_dev);
+				if (ret != 0) {
+					printk(KERN_CRIT "bmc150 bmi323_read_raw IIO_TEMP iio_device_claim_direct_mode returned %d\n", ret);
+					goto bmi323_read_raw_error;
+				}
+
+				ret = bmi323_read_u16(&data->bmi323, BMC150_BMI323_TEMPERATURE_DATA_REG, &raw_read);
+				iio_device_release_direct_mode(indio_dev);
+				if (ret != 0) {
+					printk(KERN_CRIT "bmc150 bmi323_read_raw IIO_TEMP bmi323_read_u16 returned %d\n", ret);
+					goto bmi323_read_raw_error;
+				}
+				
+				*val = sign_extend32(le16_to_cpu(raw_read), 15);
+				bmi323_set_power_state(&data->bmi323, false);
+				mutex_unlock(&data->bmi323.mutex);
+				return IIO_VAL_INT;
+
+			case IIO_ACCEL:
+				was_sleep_modified = bmi323_set_power_state(&data->bmi323, true);
+				if (was_sleep_modified != 0) {
+					ret = was_sleep_modified;
+					goto bmi323_read_raw_error_power;
+				}
+
+				ret = iio_device_claim_direct_mode(indio_dev);
+				if (ret != 0) {
+					printk(KERN_CRIT "bmc150 bmi323_read_raw IIO_ACCEL iio_device_claim_direct_mode returned %d\n", ret);
+					goto bmi323_read_raw_error;
+				}
+
+				ret = bmi323_read_u16(&data->bmi323, BMC150_BMI323_DATA_BASE_REG + (u8)(chan->scan_index), &raw_read);
+				iio_device_release_direct_mode(indio_dev);
+				if (ret != 0) {
+					printk(KERN_CRIT "bmc150 bmi323_read_raw IIO_ACCEL bmi323_read_u16 returned %d\n", ret);
+					goto bmi323_read_raw_error;
+				}
+				*val = sign_extend32(le16_to_cpu(raw_read), 15);
+				bmi323_set_power_state(&data->bmi323, false);
+				mutex_unlock(&data->bmi323.mutex);
+				return IIO_VAL_INT;
+
+			case IIO_ANGL_VEL:
+				was_sleep_modified = bmi323_set_power_state(&data->bmi323, true);
+				if (was_sleep_modified != 0) {
+					ret = was_sleep_modified;
+					goto bmi323_read_raw_error_power;
+				}
+
+				ret = iio_device_claim_direct_mode(indio_dev);
+				if (ret != 0) {
+					printk(KERN_CRIT "bmc150 bmi323_read_raw IIO_ANGL_VEL iio_device_claim_direct_mode returned %d\n", ret);
+					goto bmi323_read_raw_error;
+				}
+
+				ret = bmi323_read_u16(&data->bmi323, BMC150_BMI323_DATA_BASE_REG + (u8)(chan->scan_index), &raw_read);
+				iio_device_release_direct_mode(indio_dev);
+				if (ret != 0) {
+					printk(KERN_CRIT "bmc150 bmi323_read_raw IIO_ANGL_VEL bmi323_read_u16 returned %d\n", ret);
+					goto bmi323_read_raw_error;
+				}
+
+				*val = sign_extend32(le16_to_cpu(raw_read), 15);
+				bmi323_set_power_state(&data->bmi323, false);
+				mutex_unlock(&data->bmi323.mutex);
+				return IIO_VAL_INT;
+
+			default:
+				goto bmi323_read_raw_error;
+			}
+		}
+	case IIO_CHAN_INFO_OFFSET:
+		{
+			switch (chan->type) {
+			case IIO_TEMP:
+				*val = BMC150_BMI323_TEMPER_CENTER_VAL;
+				*val2 = 0;
+				mutex_unlock(&data->bmi323.mutex);
+				return IIO_VAL_INT;
+
+			default:
+				ret = -EINVAL;
+				goto bmi323_read_raw_error;
+			}
+		}
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+			case IIO_TEMP:
+				{
+					*val = 0;
+					*val2 = BMC150_BMI323_TEMPER_LSB_PER_KELVIN_VAL;
+					mutex_unlock(&data->bmi323.mutex);
+					return IIO_VAL_FRACTIONAL;
+				}
+			case IIO_ACCEL:
+				{
+					u8* le_raw_read = (u8*)&data->bmi323.acc_conf_reg_value;
+					for (int s = 0; s < ARRAY_SIZE(bmi323_accel_scale_map); ++s) {
+						if (((le_raw_read[0]) & ((u16)0b01110000U)) == (bmi323_accel_scale_map[s].hw_val)) {
+							*val = bmi323_accel_scale_map[s].val;
+							*val2 = bmi323_accel_scale_map[s].val2;
+
+							mutex_unlock(&data->bmi323.mutex);
+							return bmi323_accel_scale_map[s].ret_type;
+						}
+					}
+
+					ret = -EINVAL;
+					goto bmi323_read_raw_error;
+				}
+			case IIO_ANGL_VEL:
+				{
+					u8* le_raw_read = (u8*)&data->bmi323.gyr_conf_reg_value;
+					for (int s = 0; s < ARRAY_SIZE(bmi323_gyro_scale_map); ++s) {
+						if (((le_raw_read[0]) & ((u16)0b01110000U)) == (bmi323_gyro_scale_map[s].hw_val)) {
+							*val = bmi323_gyro_scale_map[s].val;
+							*val2 = bmi323_gyro_scale_map[s].val2;
+
+							mutex_unlock(&data->bmi323.mutex);
+							return bmi323_gyro_scale_map[s].ret_type;
+						}
+					}
+
+					ret = -EINVAL;
+					goto bmi323_read_raw_error;
+				}
+			default:
+				ret = -EINVAL;
+				goto bmi323_read_raw_error;
+		}
+	case IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:
+		switch (chan->type) {
+			case IIO_ACCEL:
+				{
+					u8* le_raw_read = (u8*)&data->bmi323.acc_conf_reg_value;
+					for (int s = 0; s < ARRAY_SIZE(bmi323_accel_odr_map); ++s) {
+						if (((le_raw_read[0]) & ((u16)0x0FU)) == (bmi323_accel_odr_map[s].hw_val)) {
+							/*
+							 * from tha datasheed: -3dB cut-off frequency can be configured with the bit 7 of GYR_confm,
+							 * also called acc_bw that can either be 0 or 1, where 1 means odr/4 and 0 means odr/2
+							 */
+							int freq_adj_idx = (((le_raw_read[0]) & ((u8)0x80U)) == (u8)0x00U) ? (s * 2) + 0 : (s * 2) + 1;
+							*val = bmi323_accel_3db_freq_cutoff[freq_adj_idx].val;
+							*val2 = bmi323_accel_3db_freq_cutoff[freq_adj_idx].val2;
+
+							mutex_unlock(&data->bmi323.mutex);
+							return IIO_VAL_INT_PLUS_MICRO;
+						}
+					}
+
+					ret = -EINVAL;
+					goto bmi323_read_raw_error;
+				}
+			case IIO_ANGL_VEL:
+				{
+					u8* le_raw_read = (u8*)&data->bmi323.gyr_conf_reg_value;
+					for (int s = 0; s < ARRAY_SIZE(bmi323_gyro_odr_map); ++s) {
+						if (((le_raw_read[0]) & ((u16)0x0FU)) == (bmi323_gyro_odr_map[s].hw_val)) {
+							/*
+							 * from tha datasheed: -3dB cut-off frequency can be configured with the bit 7 of GYR_confm,
+							 * also called acc_bw that can either be 0 or 1, where 1 means odr/4 and 0 means odr/2
+							 */
+							int freq_adj_idx = (((le_raw_read[0]) & ((u8)0x80U)) == (u8)0x0000U) ? (s * 2) + 0 : (s * 2) + 1;
+							*val = bmi323_gyro_3db_freq_cutoff[freq_adj_idx].val;
+							*val2 = bmi323_gyro_3db_freq_cutoff[freq_adj_idx].val2;
+
+							mutex_unlock(&data->bmi323.mutex);
+							return bmi323_gyro_3db_freq_cutoff[freq_adj_idx].ret_type;
+						}
+					}
+
+					ret = -EINVAL;
+					goto bmi323_read_raw_error;
+				}
+			default:
+			{
+				ret = -EINVAL;
+				goto bmi323_read_raw_error;
+			}
+		}
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		switch (chan->type) {
+			case IIO_TEMP:
+				{
+					was_sleep_modified = bmi323_set_power_state(&data->bmi323, true);
+					if (was_sleep_modified != 0) {
+						ret = was_sleep_modified;
+						goto bmi323_read_raw_error_power;
+					}
+
+					// while in normal or power mode the temperature sensur has a 50Hz sampling frequency
+					*val = 50;
+					*val2 = 0;
+
+					bmi323_set_power_state(&data->bmi323, false);
+					mutex_unlock(&data->bmi323.mutex);
+					return IIO_VAL_INT_PLUS_MICRO;
+				}
+			case IIO_ACCEL:
+				{
+					u8* le_raw_read = (u8*)&data->bmi323.acc_conf_reg_value;
+					for (int s = 0; s < ARRAY_SIZE(bmi323_accel_odr_map); ++s) {
+						if (((le_raw_read[0]) & ((u16)0x0FU)) == (bmi323_accel_odr_map[s].hw_val)) {
+							*val = bmi323_accel_odr_map[s].val;
+							*val2 = bmi323_accel_odr_map[s].val2;
+
+							mutex_unlock(&data->bmi323.mutex);
+							return IIO_VAL_INT_PLUS_MICRO;
+						}
+					}
+
+					ret = -EINVAL;
+					goto bmi323_read_raw_error;
+				}
+			case IIO_ANGL_VEL:
+				{
+					u8* le_raw_read = (u8*)&data->bmi323.gyr_conf_reg_value;
+					for (int s = 0; s < ARRAY_SIZE(bmi323_gyro_odr_map); ++s) {
+						if (((le_raw_read[0]) & ((u16)0x0FU)) == (bmi323_gyro_odr_map[s].hw_val)) {
+							*val = bmi323_gyro_odr_map[s].val;
+							*val2 = bmi323_gyro_odr_map[s].val2;
+
+							mutex_unlock(&data->bmi323.mutex);
+							return IIO_VAL_INT_PLUS_MICRO;
+						}
+					}
+
+					ret = -EINVAL;
+					goto bmi323_read_raw_error;
+				}
+			default:
+				ret = -EINVAL;
+				goto bmi323_read_raw_error;
+		}
+	default:
+		ret = -EINVAL;
+		goto bmi323_read_raw_error;
+	}
+
+bmi323_read_raw_error:
+	if (was_sleep_modified == 0) {
+		bmi323_set_power_state(&data->bmi323, false);
+	}
+
+bmi323_read_raw_error_power:
+	mutex_unlock(&data->bmi323.mutex);
+	return ret;
+}
+
+static int bmi323_write_raw(struct iio_dev *indio_dev,
+				  struct iio_chan_spec const *chan,
+				  int val, int val2, long mask)
+{
+	struct bmc150_accel_data *data = iio_priv(indio_dev);
+	int ret = -EINVAL, was_sleep_modified = -1;
+
+	/*
+	 * Once I got my hands on a device with IRQ pin connected (or I find otherwise a way to test triggers and interrupt code)
+	 * I will need (for some parts) to use iio_buffer_enabled(indio_dev) to avoid mistakes
+	 */
+
+	mutex_lock(&data->bmi323.mutex);
+
+	if ((data->bmi323.flags & BMI323_FLAGS_RESET_FAILED) != 0x00U) {
+		dev_err(data->bmi323.dev, "bmi323 error: device has not being woken up correctly.");
+		mutex_unlock(&data->bmi323.mutex);
+		return -EBUSY;
+	}
+
+	switch (mask) {
+	case IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:
+		switch (chan->type) {
+			
+			default:
+			{
+				ret = -EINVAL;
+				goto bmi323_write_raw_error;
+			}
+		}
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		switch (chan->type) {
+			case IIO_ACCEL:
+				for (int s = 0; s < ARRAY_SIZE(bmi323_accel_odr_map); ++s) {
+					if ((bmi323_accel_odr_map[s].val == val) && (bmi323_accel_odr_map[s].val2 == val2)) {
+						u8* le_raw_read = (u8*)&data->bmi323.acc_conf_reg_value;
+						le_raw_read[0] &= (u8)0b11110000U;
+						le_raw_read[0] |= ((u8)bmi323_gyro_odr_map[s].hw_val);
+
+						was_sleep_modified = bmi323_set_power_state(&data->bmi323, true);
+						if (was_sleep_modified != 0) {
+							ret = was_sleep_modified;
+							goto bmi323_write_raw_error_power;
+						}
+
+						ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_ACC_CONF_REG, data->bmi323.acc_conf_reg_value);
+						if (ret != 0) {
+							goto bmi323_write_raw_error;
+						}
+
+						bmi323_set_power_state(&data->bmi323, false);
+						mutex_unlock(&data->bmi323.mutex);
+						return 0;
+					}
+				}
+
+				ret = -EINVAL;
+				goto bmi323_write_raw_error;
+			case IIO_ANGL_VEL:
+				for (int s = 0; s < ARRAY_SIZE(bmi323_gyro_odr_map); ++s) {
+					if ((bmi323_gyro_odr_map[s].val == val) && (bmi323_gyro_odr_map[s].val2 == val2)) {
+						u8* le_raw_read = (u8*)&data->bmi323.gyr_conf_reg_value;
+						le_raw_read[0] &= (u8)0b11110000U;
+						le_raw_read[0] |= ((u8)bmi323_gyro_odr_map[s].hw_val);
+
+						was_sleep_modified = bmi323_set_power_state(&data->bmi323, true);
+						if (was_sleep_modified != 0) {
+							ret = was_sleep_modified;
+							goto bmi323_write_raw_error_power;
+						}
+
+						ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_GYR_CONF_REG, data->bmi323.gyr_conf_reg_value);
+						if (ret != 0) {
+							goto bmi323_write_raw_error;
+						}
+
+						bmi323_set_power_state(&data->bmi323, false);
+						mutex_unlock(&data->bmi323.mutex);
+						return 0;
+					}
+				}
+
+				ret = -EINVAL;
+				goto bmi323_write_raw_error;
+
+			/* Termometer also ends up here: its sampling frequency depends on the chip configuration and cannot be changed */
+			default:
+				ret = -EINVAL;
+				goto bmi323_write_raw_error;
+		}
+		
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+			case IIO_ACCEL:
+				for (int s = 0; s < ARRAY_SIZE(bmi323_accel_scale_map); ++s) {
+					if ((bmi323_accel_scale_map[s].val == val) && (bmi323_accel_scale_map[s].val2 == val2)) {
+						u8* le_raw_read = (u8*)&data->bmi323.acc_conf_reg_value;
+						le_raw_read[0] &= (u8)0b10001111U;
+						le_raw_read[0] |= ((u8)bmi323_accel_scale_map[s].hw_val);
+
+						was_sleep_modified = bmi323_set_power_state(&data->bmi323, true);
+						if (was_sleep_modified != 0) {
+							ret = was_sleep_modified;
+							goto bmi323_write_raw_error_power;
+						}
+
+						ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_ACC_CONF_REG, data->bmi323.acc_conf_reg_value);
+						if (ret != 0) {
+							goto bmi323_write_raw_error;
+						}
+
+						bmi323_set_power_state(&data->bmi323, false);
+						mutex_unlock(&data->bmi323.mutex);
+						return 0;
+					}
+				}
+
+				dev_warn(data->bmi323.dev, "bmi323 error: accel scale val=%d,val2=%d unavailable: ignoring.", val, val2);
+
+				ret = -EINVAL;
+				goto bmi323_write_raw_error;
+			case IIO_ANGL_VEL:
+				for (int s = 0; s < ARRAY_SIZE(bmi323_gyro_scale_map); ++s) {
+					if ((bmi323_gyro_scale_map[s].val == val) && (bmi323_gyro_scale_map[s].val2 == val2)) {
+						u8* le_raw_read = (u8*)&data->bmi323.gyr_conf_reg_value;
+						le_raw_read[0] &= (u8)0b10001111U;
+						le_raw_read[0] |= ((u8)bmi323_gyro_scale_map[s].hw_val);
+
+						was_sleep_modified = bmi323_set_power_state(&data->bmi323, true);
+						if (was_sleep_modified != 0) {
+							ret = was_sleep_modified;
+							goto bmi323_write_raw_error_power;
+						}
+
+						ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_GYR_CONF_REG, data->bmi323.acc_conf_reg_value);
+						if (ret != 0) {
+							goto bmi323_write_raw_error;
+						}
+
+						bmi323_set_power_state(&data->bmi323, false);
+						mutex_unlock(&data->bmi323.mutex);
+						return 0;
+					}
+				}
+
+				dev_warn(data->bmi323.dev, "bmi323 error: gyro scale val=%d,val2=%d unavailable: ignoring.", val, val2);
+
+				ret = -EINVAL;
+				goto bmi323_write_raw_error;
+
+			default:
+				ret = -EINVAL;
+				goto bmi323_write_raw_error;
+		}
+
+	default:
+		ret = -EINVAL;
+		goto bmi323_write_raw_error;
+	}
+
+bmi323_write_raw_error:
+	if (was_sleep_modified == 0) {
+		bmi323_set_power_state(&data->bmi323, false);
+	}
+
+bmi323_write_raw_error_power:
+	mutex_unlock(&data->bmi323.mutex);
+	return ret;
+}
+
+static int bmi323_read_avail(struct iio_dev *indio_dev,
+			     struct iio_chan_spec const *chan,
+			     const int **vals, int *type, int *length,
+			     long mask)
+{
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_ACCEL:
+			*type = IIO_VAL_INT_PLUS_MICRO;
+			*vals = bmi323_accel_scales;
+			*length = ARRAY_SIZE(bmi323_accel_scales);
+			return IIO_AVAIL_LIST;
+		case IIO_ANGL_VEL:
+			*type = IIO_VAL_INT_PLUS_NANO;
+			*vals = bmi323_gyro_scales;
+			*length = ARRAY_SIZE(bmi323_gyro_scales);
+			return IIO_AVAIL_LIST;
+		default:
+			return -EINVAL;
+		}
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*type = IIO_VAL_INT_PLUS_MICRO;
+		*vals = bmi323_sample_freqs;
+		*length = ARRAY_SIZE(bmi323_sample_freqs);
+		return IIO_AVAIL_LIST;
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct iio_info bmi323_accel_info = {
+	.read_raw		= bmi323_read_raw,
+	.write_raw		= bmi323_write_raw,
+	.read_avail		= bmi323_read_avail,
+};
+
+
+/**
+ * iio_simple_dummy_trigger_h() - the trigger handler function
+ * @irq: the interrupt number
+ * @p: private data - always a pointer to the poll func.
+ *
+ * This is the guts of buffered capture. On a trigger event occurring,
+ * if the pollfunc is attached then this handler is called as a threaded
+ * interrupt (and hence may sleep). It is responsible for grabbing data
+ * from the device and pushing it into the associated buffer.
+ *
+ * At the moment data is faked as what the device would report in a
+ * "overread" FIFO buffer situation.
+ */
+static irqreturn_t iio_bmi323_trigger_h(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	u16 *data;
+	//struct bmc150_accel_data *indio_data = iio_priv(indio_dev);
+
+	data = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);
+	if (!data)
+		goto bmi323_irq_done;
+
+	/*
+	CHANNEL			scan_index
+	==========================
+	
+	ACCEL_X				0
+	ACCEL_Y				1
+	ACCEL_Y				2
+	GYRO_X				3
+	GYRO_Y				4
+	GYRO_Z				5
+	TEMP				6
+	TIMESTAMP			?
+	*/
+
+	/*int ret = 0;
+	u8 read_bytes[] = { 0xFF, 0xFF, 0xFF, 0xFF};
+	int d_idx = 0;
+	u8 reg = 0x03;
+	for (u32 i = 0; i < indio_dev->masklength; ++i) {
+		if (((0x0001U << i) & (*indio_dev->active_scan_mask)) != 0) {
+			
+			struct i2c_client*  i2c_dev = indio_data->bmi323.i2c_client;
+			if (i2c_dev != NULL) {
+				ret = i2c_smbus_read_i2c_block_data(i2c_dev, reg + i, sizeof(read_bytes), &read_bytes[0]);
+				if (ret != 4) {
+					goto bmi323_irq_done;
+				}
+
+				data[d_idx++] = ((u16)read_bytes[2] << (u16)8U) | ((u16)read_bytes[3]);
+			} else {
+				// TODO: what about SPI?
+				goto bmi323_irq_done;
+			}
+		}
+	}*/
+
+	int j = 0, i = 0;
+	for_each_set_bit(j, indio_dev->active_scan_mask, indio_dev->masklength)
+		data[i++] = cpu_to_le16(0x8000);
+
+	iio_push_to_buffers_with_timestamp(indio_dev, data,
+					   iio_get_time_ns(indio_dev));
+
+	kfree(data);
+
+bmi323_irq_done:
+	/*
+	 * Tell the core we are done with this trigger and ready for the
+	 * next one.
+	 */
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * A very basic scan mask: everything can work in conjunction with everything else so no need to worry about
+ * managing conbinations of mutually exclusive data sources...
+ */
+static const unsigned long bmi323_accel_scan_masks[] = {
+					BIT(BMI323_ACCEL_AXIS_X) | BIT(BMI323_ACCEL_AXIS_Y) | BIT(BMI323_ACCEL_AXIS_Z) | BIT(BMI323_GYRO_AXIS_X) | BIT(BMI323_GYRO_AXIS_Y) | BIT(BMI323_GYRO_AXIS_Z) | BIT(BMI323_TEMP),
+					0};
+
+int bmi323_iio_init(struct iio_dev *indio_dev) {
+	const struct iio_dev_attr **fifo_attrs = NULL;
+	struct bmc150_accel_data *data = iio_priv(indio_dev);
+	struct irq_data *irq_desc = NULL;
+
+	if (data->bmi323.i2c_client != NULL) {
+		data->bmi323.dev = &data->bmi323.i2c_client->dev;
+	} else if (data->bmi323.spi_client != NULL) {
+		data->bmi323.dev = &data->bmi323.spi_client->dev;
+	} else {
+		return -ENODEV;
+	}
+
+	int ret = 0;
+
+	mutex_init(&data->bmi323.mutex);
+
+	// FIFO enabled for gyro, accel and temp. Overwrite older samples.
+	data->bmi323.fifo_conf_reg_value = cpu_to_le16((u16)0x0E00U);
+
+	// now set the (default) normal mode...
+	// normal mode: 0x4000
+	// no averaging: 0x0000
+	data->bmi323.acc_conf_reg_value = cpu_to_le16(0x4000 | ((u16)BMC150_BMI323_ACCEL_RANGE_2_VAL << (u16)4U) | ((u16)BMC150_BMI323_ACCEL_ODR_100_VAL));
+	
+	// now set the (default) normal mode...
+	// normal mode: 0x4000
+	// no averaging: 0x0000
+	// filtering to ODR/2: 0x0000
+	data->bmi323.gyr_conf_reg_value = cpu_to_le16(0x4000 | ((u16)BMC150_BMI323_GYRO_RANGE_125_VAL << (u16)4U) | ((u16)BMC150_BMI323_ACCEL_ODR_100_VAL));
+
+	// the datasheet states that FIFO buffer MUST be enabled before enabling any sensor
+	ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_FIFO_CONF_REG, data->bmi323.fifo_conf_reg_value);
+	if (ret != 0) {
+		return -1;
+	}
+
+	ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_ACC_CONF_REG, data->bmi323.acc_conf_reg_value);
+	if (ret != 0) {
+		return -1;
+	}
+
+	ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_GYR_CONF_REG, data->bmi323.gyr_conf_reg_value);
+	if (ret != 0) {
+		return -2;
+	}
+
+	indio_dev->channels = bmi323_channels;
+	indio_dev->num_channels = ARRAY_SIZE(bmi323_channels);
+	indio_dev->name = "bmi323";
+	indio_dev->available_scan_masks = bmi323_accel_scan_masks;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->info = &bmi323_accel_info;
+	indio_dev->label = "bmi323-accel_base";
+
+	if (data->bmi323.irq > 0) {
+		dev_info(data->bmi323.dev, "IRQ pin reported as connected: %d", data->bmi323.irq);
+
+		irq_desc = irq_get_irq_data(data->bmi323.irq);
+		if (!irq_desc) {
+			dev_err(data->bmi323.dev, "Could not find IRQ %d. ignoring it.\n", data->bmi323.irq);
+			goto bmi323_iio_init_missing_irq_pin;
+		}
+
+		/*
+		 * register triggers BEFORE buffer setup so that they are cleared
+		 * on emergence exit by bmi323_iio_init_err_trigger_unregister.
+		 *
+		 * This is just a placeholder until I can get my hands on a bmi323
+		 * device that has the IRQ pin actually connected to the CPU.
+		 */
+
+		/* here resume operation with the module part common to irq and non-irq enabled code. */
+		goto bmi323_iio_init_common_irq_and_not_irq;
+	}
+	
+bmi323_iio_init_missing_irq_pin:
+	dev_info(data->bmi323.dev, "IRQ pin NOT connected (irq=%d). Will continue normally without triggers.", data->bmi323.irq);
+
+bmi323_iio_init_common_irq_and_not_irq:
+	/* Once orientation matrix is implemented switch this to iio_triggered_buffer_setup_ext. */
+	ret = iio_triggered_buffer_setup(indio_dev, NULL,
+					  iio_bmi323_trigger_h,
+					  &bmi323_buffer_ops);
+	if (ret < 0) {
+		dev_err(data->bmi323.dev, "Failed: iio triggered buffer setup: %d\n", ret);
+		goto bmi323_iio_init_err_trigger_unregister;
+	}
+
+	ret = pm_runtime_set_active(data->bmi323.dev);
+	if (ret) {
+		dev_err(data->bmi323.dev, "bmi323 unable to initialize runtime PD: pm_runtime_set_active returned %d\n", ret);
+		goto bmi323_iio_init_err_buffer_cleanup;
+	}
+
+	pm_runtime_enable(data->bmi323.dev);dev_err(data->bmi323.dev, "bmi323 pm_runtime_set_autosuspend_delay\n");
+	pm_runtime_set_autosuspend_delay(data->bmi323.dev,
+					 BMC150_BMI323_AUTO_SUSPEND_DELAY_MS);
+	pm_runtime_use_autosuspend(data->bmi323.dev);
+
+	ret = iio_device_register(indio_dev);
+	if (ret < 0) {
+		dev_err(data->bmi323.dev, "bmi323 unable to register iio device: %d\n", ret);
+		goto bmi323_iio_init_err_pm_cleanup;
+	}
+
+	return 0;
+
+bmi323_iio_init_err_pm_cleanup:
+	pm_runtime_dont_use_autosuspend(data->bmi323.dev);
+	pm_runtime_disable(data->bmi323.dev);
+bmi323_iio_init_err_buffer_cleanup:
+	iio_triggered_buffer_cleanup(indio_dev);
+bmi323_iio_init_err_trigger_unregister:
+	/*
+	 * unregister triggers if they have been setup already.
+	 * iio_trigger_unregister shall be used in that regard.
+	 *
+	 * This is just a placeholder until I can get my hands on a bmi323
+	 * device that has the IRQ pin actually connected to the CPU.
+	 */
+
+	return ret;
+}
+EXPORT_SYMBOL_NS_GPL(bmi323_iio_init, IIO_BMC150);
+
+void bmi323_iio_deinit(struct iio_dev *indio_dev) {
+	struct bmc150_accel_data *data = iio_priv(indio_dev);
+	struct device* dev = bmi323_get_managed_device(&data->bmi323);
+
+	iio_device_unregister(indio_dev);
+
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_put_noidle(dev);
+
+	iio_triggered_buffer_cleanup(indio_dev);
+
+	//iio_device_free(indio_dev); // this isn't done in the bmg160 driver nor in other drivers so I guess I shouldn't do it too
+	
+	mutex_unlock(&data->bmi323.mutex);
+	bmi323_chip_rst(&data->bmi323);
+	mutex_unlock(&data->bmi323.mutex);
+}
+EXPORT_SYMBOL_NS_GPL(bmi323_iio_deinit, IIO_BMC150);
+
 #ifdef CONFIG_PM_SLEEP
 static int bmc150_accel_suspend(struct device *dev)
 {
 	struct iio_dev *indio_dev = dev_get_drvdata(dev);
 	struct bmc150_accel_data *data = iio_priv(indio_dev);
 
+	if (data->dev_type == BMI323) {
+		int ret;
+
+		//dev_warn(dev, "bmi323 suspending driver...");
+		
+		// here push the register GYRO & ACCEL configuration and issue a reset so that chip goes to sleep mode (the default one after a reset)
+		mutex_unlock(&data->bmi323.mutex);
+
+		ret = bmi323_chip_rst(&data->bmi323);
+		mutex_unlock(&data->bmi323.mutex);
+		if (ret != 0) {
+			dev_err(dev, "bmi323 error in suspend on bmi323_chip_rst: %d\n", ret);
+			data->bmi323.flags |= BMI323_FLAGS_RESET_FAILED;
+			return -EAGAIN;
+		}
+		
+		return 0;
+	}
+
 	mutex_lock(&data->mutex);
 	bmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_SUSPEND, 0);
 	mutex_unlock(&data->mutex);
@@ -1844,6 +3594,56 @@ static int bmc150_accel_resume(struct device *dev)
 	struct iio_dev *indio_dev = dev_get_drvdata(dev);
 	struct bmc150_accel_data *data = iio_priv(indio_dev);
 
+	if (data->dev_type == BMI323) {
+		int ret;
+
+		//dev_warn(dev, "bmi323 resuming driver...");
+
+		// here pop the register GYRO & ACCEL configuration and issue a reset so that chip goes to sleep mode (the default one after a reset)
+		mutex_lock(&data->bmi323.mutex);
+
+		// this was done already in runtime_sleep function.
+		if ((data->bmi323.flags & BMI323_FLAGS_RESET_FAILED) != 0x00U) {
+			ret = bmi323_chip_rst(&data->bmi323);
+			if (ret == 0) {
+				data->bmi323.flags &= ~BMI323_FLAGS_RESET_FAILED;
+			} else {
+				goto bmi323_bmc150_accel_resume_terminate;
+			}
+		}
+		
+		ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_FIFO_CONF_REG, data->bmi323.fifo_conf_reg_value);
+		if (ret != 0) {
+			goto bmi323_bmc150_accel_resume_terminate;
+		}
+
+		ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_GYR_CONF_REG, data->bmi323.gyr_conf_reg_value);
+		if (ret != 0) {
+			goto bmi323_bmc150_accel_resume_terminate;
+		}
+
+		ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_ACC_CONF_REG, data->bmi323.acc_conf_reg_value);
+		if (ret != 0) {
+			goto bmi323_bmc150_accel_resume_terminate;
+		}
+
+bmi323_bmc150_accel_resume_terminate:
+		mutex_unlock(&data->bmi323.mutex);
+		if (ret != 0) {
+			return -EAGAIN;
+		}
+		
+		/*
+		 * datasheet says "Start-up time": suspend to high performance mode is tipically 30ms,
+		 * however when setting this to 32 or even higher the first reading from the gyro (unlike accel part)
+		 * is actually the (wrong) default value 0x8000 so it is better to sleep a bit longer
+		 * to prevent issues and give time to the sensor to pick up first readings...
+		 */
+		msleep_interruptible(64);
+
+		return 0;
+	}
+
 	mutex_lock(&data->mutex);
 	bmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_NORMAL, 0);
 	bmc150_accel_fifo_set_mode(data);
@@ -1863,10 +3663,27 @@ static int bmc150_accel_runtime_suspend(struct device *dev)
 	struct bmc150_accel_data *data = iio_priv(indio_dev);
 	int ret;
 
+	if (data->dev_type == BMI323) {
+		//dev_warn(dev, "bmi323 suspending runtime...");
+		
+		/*
+		 * Every operation requiring this function have the mutex locked already:
+		 * with mutex_lock(&data->bmi323.mutex);
+		 */
+		ret = bmi323_chip_rst(&data->bmi323);
+		if (ret != 0) {
+			dev_err(dev, "bmi323 error in runtime_suspend on bmi323_chip_rst: %d\n", ret);
+			data->bmi323.flags |= BMI323_FLAGS_RESET_FAILED;
+			return -EAGAIN;
+		}
+		
+		return 0;
+	}
+
 	ret = bmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_SUSPEND, 0);
 	if (ret < 0)
 		return -EAGAIN;
-
+		
 	return 0;
 }
 
@@ -1877,6 +3694,59 @@ static int bmc150_accel_runtime_resume(struct device *dev)
 	int ret;
 	int sleep_val;
 
+	if (data->dev_type == BMI323) {
+		//dev_warn(dev, "bmi323 resuming runtime...");
+
+		/*
+		 * Every operation requiring this function have the mutex locked already:
+		 * with mutex_lock(&data->bmi323.mutex);
+		 */
+
+		// recover from a bad state if it was left that way on reuntime_suspend
+		if ((data->bmi323.flags & BMI323_FLAGS_RESET_FAILED) != 0x00U) {
+			ret = bmi323_chip_rst(&data->bmi323);
+			if (ret == 0) {
+				data->bmi323.flags &= ~BMI323_FLAGS_RESET_FAILED;
+			} else {
+				goto bmi323_bmc150_accel_runtime_resume_terminate;
+			}
+		}
+
+		ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_FIFO_CONF_REG, data->bmi323.fifo_conf_reg_value);
+		if (ret != 0) {
+			dev_err(dev, "bmi323 writing to GYR_CONF register failed");
+			goto bmi323_bmc150_accel_runtime_resume_terminate;
+		}
+
+		ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_GYR_CONF_REG, data->bmi323.gyr_conf_reg_value);
+		if (ret != 0) {
+			dev_err(dev, "bmi323 writing to GYR_CONF register failed");
+			goto bmi323_bmc150_accel_runtime_resume_terminate;
+		}
+
+		ret = bmi323_write_u16(&data->bmi323, BMC150_BMI323_ACC_CONF_REG, data->bmi323.acc_conf_reg_value);
+		if (ret != 0) {
+			dev_err(dev, "bmi323 writing to ACC_CONF register failed");
+			goto bmi323_bmc150_accel_runtime_resume_terminate;
+		}
+
+bmi323_bmc150_accel_runtime_resume_terminate:
+		if (ret != 0) {
+			dev_err(dev, "bmi323 bmc150_accel_runtime_resume -EAGAIN");
+			return -EAGAIN;
+		}
+		
+		/*
+		 * datasheet says "Start-up time": suspend to high performance mode is tipically 30ms,
+		 * however when setting this to 32 or even higher the first reading from the gyro (unlike accel part)
+		 * is actually the (wrong) default value 0x8000 so it is better to sleep a bit longer
+		 * to prevent issues and give time to the sensor to pick up first readings...
+		 */
+		msleep_interruptible(64);
+
+		return 0;
+	}
+
 	ret = bmc150_accel_set_mode(data, BMC150_ACCEL_SLEEP_MODE_NORMAL, 0);
 	if (ret < 0)
 		return ret;
diff --git a/drivers/iio/accel/bmc150-accel-i2c.c b/drivers/iio/accel/bmc150-accel-i2c.c
index ee1ba134ad42..a26b08f6feb3 100644
--- a/drivers/iio/accel/bmc150-accel-i2c.c
+++ b/drivers/iio/accel/bmc150-accel-i2c.c
@@ -173,16 +173,92 @@ static void bmc150_acpi_dual_accel_remove(struct i2c_client *client) {}
 
 static int bmc150_accel_probe(struct i2c_client *client)
 {
+	int ret;
+	u8 chip_id_first[4];
+	enum bmc150_device_type dev_type = BMC150;
 	const struct i2c_device_id *id = i2c_client_get_device_id(client);
 	struct regmap *regmap;
 	const char *name = NULL;
 	enum bmc150_type type = BOSCH_UNKNOWN;
-	bool block_supported =
+	bool block_supported = false;
+
+	/* reads 4 bytes (2 dummy + 2 good) from the i2c CHIP_ID device register */
+	ret = i2c_smbus_read_i2c_block_data(client, 0x00, 4, &chip_id_first[0]);
+	if (ret != 4) {
+		dev_info(&client->dev, "error checking if the bmc150 is in fact a bmi323: i2c_smbus_read_i2c_block_data = %d: reg = 0x%02x.\n\tIt probably is a bmc150 as correctly reported by the ACPI entry.", (int)ret, 0x00);
+		goto bmi150_old_probe;
+	}
+
+	// at this point we have enough data to know what chip we are handling
+	dev_type = (chip_id_first[2] == 0x43) ? BMI323 : dev_type;
+
+	if (dev_type == BMI323) {
+		dev_warn(&client->dev, "bmc323: what the ACPI table reported as a bmc150 is in fact a bmc323\n");
+
+		struct iio_dev *indio_dev = devm_iio_device_alloc(&client->dev, sizeof(struct bmc150_accel_data));
+		if (!indio_dev) {
+			dev_err(&client->dev, "bmc323 init process failed: out of memory\n");
+
+			return -ENOMEM;
+		}
+
+		dev_set_drvdata(&client->dev, indio_dev);
+		struct bmc150_accel_data *data = iio_priv(indio_dev);
+		data->dev_type = dev_type;
+
+		struct bmi323_private_data* bmi323_data = &data->bmi323;
+		bmi323_data->i2c_client = client;
+		bmi323_data->spi_client = NULL;
+		bmi323_data->irq = client->irq;
+
+		/*
+		 * VDD   is the analog and digital domain voltage supply
+		 * VDDIO is the digital I/O voltage supply
+		 */
+		bmi323_data->regulators[0].supply = "vdd";
+		bmi323_data->regulators[1].supply = "vddio";
+		ret = devm_regulator_bulk_get(&client->dev,
+						ARRAY_SIZE(bmi323_data->regulators),
+						bmi323_data->regulators);
+		if (ret) {
+			return dev_err_probe(&client->dev, ret, "failed to get regulators\n");
+		}
+
+		ret = regulator_bulk_enable(ARRAY_SIZE(bmi323_data->regulators),
+						bmi323_data->regulators);
+		if (ret) {
+			iio_device_free(indio_dev);
+
+			dev_err(&client->dev, "failed to enable regulators: %d\n", ret);
+			return ret;
+		}
+
+		ret = bmi323_chip_rst(bmi323_data);
+		if (ret != 0) {
+			dev_err(&client->dev, "bmc323: error issuing the chip reset: %d\n", ret);
+			return ret;
+		}
+
+		dev_info(&client->dev, "bmc323: chip reset success: starting the iio subsystem binding\n");
+		
+		ret = bmi323_iio_init(indio_dev);
+		if (ret != 0) {
+			return ret;
+		}
+
+		
+
+		return 0;
+	}
+	
+bmi150_old_probe:
+	dev_info(&client->dev, "executing the normal procedure for a bmc150...");
+
+	block_supported =
 		i2c_check_functionality(client->adapter, I2C_FUNC_I2C) ||
 		i2c_check_functionality(client->adapter,
 					I2C_FUNC_SMBUS_READ_I2C_BLOCK);
-	int ret;
-
+	
 	regmap = devm_regmap_init_i2c(client, &bmc150_regmap_conf);
 	if (IS_ERR(regmap)) {
 		dev_err(&client->dev, "Failed to initialize i2c regmap\n");
@@ -198,7 +274,7 @@ static int bmc150_accel_probe(struct i2c_client *client)
 				      type, name, block_supported);
 	if (ret)
 		return ret;
-
+			
 	/*
 	 * The !id check avoids recursion when probe() gets called
 	 * for the second client.
@@ -211,6 +287,15 @@ static int bmc150_accel_probe(struct i2c_client *client)
 
 static void bmc150_accel_remove(struct i2c_client *client)
 {
+	struct iio_dev *indio_dev = dev_get_drvdata(&client->dev);
+	struct bmc150_accel_data *data = iio_priv(indio_dev);
+
+	if (data->dev_type == BMI323) {
+		bmi323_iio_deinit(indio_dev);
+
+		return;
+	}
+
 	bmc150_acpi_dual_accel_remove(client);
 
 	bmc150_accel_core_remove(&client->dev);
diff --git a/drivers/iio/accel/bmc150-accel.h b/drivers/iio/accel/bmc150-accel.h
index 7775c5edaeef..e84dded7c0ec 100644
--- a/drivers/iio/accel/bmc150-accel.h
+++ b/drivers/iio/accel/bmc150-accel.h
@@ -8,6 +8,14 @@
 #include <linux/regulator/consumer.h>
 #include <linux/workqueue.h>
 
+/*
+ * the bmi323 needs raw access to spi and i2c: I cannot use regmap
+ * as this device expects i2c writes to be 2 bytes,
+ * spi reads to be 3 bytes and i2c reads to be 4 bytes.
+ */
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+
 struct regmap;
 struct i2c_client;
 struct bmc150_accel_chip_info;
@@ -34,6 +42,11 @@ struct bmc150_accel_interrupt {
 	atomic_t users;
 };
 
+enum bmc150_device_type {
+	BMC150,
+	BMI323,
+};
+
 struct bmc150_accel_trigger {
 	struct bmc150_accel_data *data;
 	struct iio_trigger *indio_trig;
@@ -55,6 +68,21 @@ enum bmc150_accel_trigger_id {
 	BMC150_ACCEL_TRIGGERS,
 };
 
+#define BMI323_FLAGS_RESET_FAILED 0x00000001U
+
+struct bmi323_private_data {
+	struct regulator_bulk_data regulators[2];
+	struct i2c_client* i2c_client;
+	struct spi_device* spi_client;
+	struct device* dev; // pointer at i2c_client->dev or spi_client->dev
+	struct mutex mutex;
+	int irq;
+	u32 flags;
+	u16 acc_conf_reg_value;
+	u16 gyr_conf_reg_value;
+	u16 fifo_conf_reg_value;
+};
+
 struct bmc150_accel_data {
 	struct regmap *regmap;
 	struct regulator_bulk_data regulators[2];
@@ -83,7 +111,67 @@ struct bmc150_accel_data {
 	void (*resume_callback)(struct device *dev);
 	struct delayed_work resume_work;
 	struct iio_mount_matrix orientation;
-};
+	enum bmc150_device_type dev_type;
+	struct bmi323_private_data bmi323;
+	};
+
+/**
+ * This function performs a write of a u16 little-endian (regardless of CPU architecture) integer
+ * to a device register. Returns 0 on success or an error code otherwise.
+ *
+ * PRE: in_value holds the data to be sent to the sensor, in little endian format even on big endian
+ *      architectures.
+ *
+ * NOTE: bmi323->dev can be NULL (not yet initialized) when this function is called
+ *			therefore it is not needed and is not used inside the function
+ *
+ * WARNING: this function does not lock any mutex and synchronization MUST be performed by the caller
+ */
+int bmi323_write_u16(struct bmi323_private_data *bmi323, u8 in_reg, u16 in_value);
+
+/**
+ * This function performs a read of "good" values from the bmi323 discarding what
+ * in the datasheet is described as "dummy data": additional useles bytes.
+ *
+ * PRE: bmi323 has been partially initialized: i2c_device and spi_devices MUST be set to either
+ *      the correct value or NULL
+ *
+ * NOTE: bmi323->dev can be NULL (not yet initialized) when this function is called
+ *			therefore it is not needed and is not used inside the function
+ *
+ * POST: on success out_value is written with data from the sensor, as it came out, so the
+ *       content is little-endian even on big endian architectures
+ *
+ * WARNING: this function does not lock any mutex and synchronization MUST be performed by the caller
+ */
+int bmi323_read_u16(struct bmi323_private_data *bmi323, u8 in_reg, u16* out_value);
+
+int bmi323_chip_check(struct bmi323_private_data *bmi323);
+
+/**
+ * Reset the chip in a known state that is ready to accept commands, but is not configured therefore after calling this function
+ * it is required to load a new configuration to start data acquisition.
+ *
+ * PRE: bmi323 has been fully identified and partially initialized
+ *
+ * NOTE: after issuing a reset the the chip will be in what it is called "suspended mode" and the feature angine is
+ * ready to be set. This mode has everything disabled and consumes aroud 15uA.
+ *
+ * When removing the driver or suspend has been requested it's best to reset the chip so that power consumption
+ * will be the lowest possible.
+ */
+int bmi323_chip_rst(struct bmi323_private_data *bmi323);
+
+/**
+ * This function  MUST be called in probe and is responsible for registering the userspace sysfs.
+ *
+ * The indio_dev MUST have been allocated but not registered. This function will perform userspace registration.
+ *
+ * @param indio_dev the industrual io device already allocated but not yet registered
+ */
+int bmi323_iio_init(struct iio_dev *indio_dev);
+
+void bmi323_iio_deinit(struct iio_dev *indio_dev);
 
 int bmc150_accel_core_probe(struct device *dev, struct regmap *regmap, int irq,
 			    enum bmc150_type type, const char *name,
-- 
2.42.0


From fc1c2c2fce55e90d2e942e4109193eb73125ff5c Mon Sep 17 00:00:00 2001
From: Denis <benato.denis96@gmail.com>
Date: Mon, 18 Sep 2023 02:04:24 +0200
Subject: [PATCH 2/2] Removed two warnings that I previously missed

---
 drivers/iio/accel/bmc150-accel-core.c | 27 ---------------------------
 1 file changed, 27 deletions(-)

diff --git a/drivers/iio/accel/bmc150-accel-core.c b/drivers/iio/accel/bmc150-accel-core.c
index 5ac25c344385..79d7d0694add 100644
--- a/drivers/iio/accel/bmc150-accel-core.c
+++ b/drivers/iio/accel/bmc150-accel-core.c
@@ -2697,32 +2697,6 @@ int bmi323_chip_check(struct bmi323_private_data *bmi323)
 }
 EXPORT_SYMBOL_NS_GPL(bmi323_chip_check, IIO_BMC150);
 
-static irqreturn_t bmi323_trigger_handler(int irq, void *p)
-{
-	struct iio_poll_func *pf = p;
-	struct iio_dev *indio_dev = pf->indio_dev;
-/*	
-	struct bmc150_accel_data *data = iio_priv(indio_dev);
-	
-	int ret;
-
-	mutex_lock(&data->mutex);
-	ret = regmap_bulk_read(data->regmap, BMC150_ACCEL_REG_XOUT_L,
-			       data->buffer, AXIS_MAX * 2);
-	mutex_unlock(&data->mutex);
-	if (ret < 0)
-		goto err_read;
-
-	iio_push_to_buffers_with_timestamp(indio_dev, data->buffer,
-					   pf->timestamp);
-err_read:
-*/
-	iio_trigger_notify_done(indio_dev->trig);
-
-
-	return IRQ_HANDLED;
-}
-
 static int bmi323_buffer_preenable(struct iio_dev *indio_dev)
 {
 	struct bmc150_accel_data *data = iio_priv(indio_dev);
@@ -3412,7 +3386,6 @@ static const unsigned long bmi323_accel_scan_masks[] = {
 					0};
 
 int bmi323_iio_init(struct iio_dev *indio_dev) {
-	const struct iio_dev_attr **fifo_attrs = NULL;
 	struct bmc150_accel_data *data = iio_priv(indio_dev);
 	struct irq_data *irq_desc = NULL;
 
-- 
2.42.0

